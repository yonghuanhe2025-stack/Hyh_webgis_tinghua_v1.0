<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FINAL｜只同步姿态的 STL 播放器（本地目录自动监测｜r146 离线｜SolidWorks交互｜稳定优化）</title>
  <!-- 必读：
    1) 将本 HTML 与如下 3 个脚本放同一目录（均取自 three.js r146 非模块版，支持 file://）：
       - three.min.js            https://raw.githubusercontent.com/mrdoob/three.js/r146/build/three.min.js
       - OrbitControls.js        https://raw.githubusercontent.com/mrdoob/three.js/r146/examples/js/controls/OrbitControls.js
       - STLLoader.js            https://raw.githubusercontent.com/mrdoob/three.js/r146/examples/js/loaders/STLLoader.js
    2) 打开方式：可直接双击；若被安全策略拦截，建议在当前目录运行 `python -m http.server 5500`，浏览器访问 http://localhost:5500/
    3) SolidWorks风格交互（已内置）：
       - 中键拖动 = 旋转（Orbit）
       - Ctrl + 中键拖动 = 平移（Pan）
       - Shift + 中键拖动 = 变焦（Dolly）
       - 滚轮 = 缩放（Zoom）
       - 双击画布 = 视角复位（Fit）
    4) 本版针对“运行一会儿卡住”做了1~6点联合优化：
       - ① 定时器单次执行锁，杜绝异步重入
       - ② 日志限长（默认最多 500 行）
       - ③ 只读文件尾部（最多 64KB），避免整文件 to text 造成 GC 压力
       - ④ 目录重扫节流；仅在周期到期时重扫
       - ⑤ 读取失败容错（文件写锁）+ 退避
       - ⑥ 末行未完成保护（优先取包含 $GPCHC 的完整行，否则取最后一条完整行）
  -->
  <style>
    :root{ --bg:#0b1221; --panel:#111827; --muted:#9fb1d1; --text:#e7eefc; --accent:#38bdf8; --border:#233043 }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
    #app{position:fixed; inset:0}
    #viewer{position:absolute; inset:0; display:block; width:100%; height:100%}
    .chrome{position:fixed; inset:12px; pointer-events:none; z-index:10}
    .panel{pointer-events:auto; background:linear-gradient(180deg, rgba(17,24,39,.92), rgba(17,24,39,.8)); border:1px solid var(--border); border-radius:16px; padding:12px 14px; box-shadow:0 10px 30px rgba(0,0,0,.35); backdrop-filter: blur(6px); width:min(920px, 96vw)}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .title{font-weight:700; letter-spacing:.3px}
    .muted{color:var(--muted); font-size:12px}
    .btn, select, input[type="number"], input[type="url"], input[type="file"]{appearance:none; border:1px solid var(--border); background:#0f172a; color:var(--text); border-radius:12px; padding:8px 12px; cursor:pointer; transition:.2s transform,.2s opacity; font:inherit}
    .btn:hover{transform:translateY(-1px)}
    .legend{position:fixed; right:12px; bottom:12px; background:rgba(17,24,39,.85); border:1px solid var(--border); border-radius:12px; padding:8px 10px; font-size:12px}
    .logbox{background:#0b1221; border:1px solid var(--border); border-radius:10px; padding:8px; overflow:auto; height:160px; font:12px/1.4 ui-monospace, Consolas, Menlo}
    .logline{white-space:pre-wrap}
    .logline.info{color:#9fb1d1}
    .logline.warn{color:#ffd166}
    .logline.error{color:#ff6b6b}
    .hidden{display:none !important}
    .kbd{padding:0 6px; border:1px solid var(--border); border-radius:6px; font:12px/20px ui-monospace,Consolas,Menlo; background:#0b1221; color:var(--muted)}
  </style>
</head>
<body>
<div id="app">
  <canvas id="viewer"></canvas>

  <div class="chrome" id="chrome">
    <div class="panel">
      <div class="row" style="justify-content:space-between; align-items:baseline">
        <div>
          <div class="title">只同步姿态的 STL 播放器（本地目录自动监测｜SolidWorks交互）</div>
          <div class="muted">r146 离线 · $GPCHC/四元数/欧拉 解析 · Y-up · 仅旋转不位移</div>
        </div>
        <div class="row">
          <button id="focusMode" class="btn" title="隐藏控制面板与状态">专注模式</button>
          <button id="fullscreen" class="btn" title="切换浏览器全屏 (F)">全屏</button>
        </div>
      </div>

      <div class="row" style="margin-top:8px; gap:8px">
        <button id="pickDir" class="btn">选择 test_data 目录</button>
        <span class="muted" id="dirStatus">未选择</span>
      </div>

      <div class="row" style="margin-top:8px; gap:8px">
        <input id="stlFile" type="file" accept=".stl" class="btn" />
        <button id="inlineSTL" class="btn">内置立方体</button>
        <button id="fit" class="btn">视角复位</button>
        <label class="muted">播放速率× <input id="rate" type="number" value="1" step="0.25" style="width:80px"></label>
        <label class="muted">刷新间隔(ms) <input id="interval" type="number" value="100" step="1" style="width:90px"></label>
        <label class="muted">自动监测目录<input id="autoWatch" type="checkbox" checked></label>
        <label class="muted">监测周期(ms) <input id="watchInterval" type="number" value="100" step="100" style="width:90px"></label>
        <button id="start" class="btn">开始播放</button>
        <button id="stop" class="btn">停止</button>
      </div>

      <div class="row" style="margin-top:8px; gap:8px">
        <label class="muted">姿态欧拉顺序
          <select id="eulerOrder" class="btn">
            <option value="ZXY">ZXY（默认）</option>
            <option value="ZYX">ZYX</option>
            <option value="YXZ">YXZ</option>
            <option value="XYZ">XYZ</option>
          </select>
        </label>
        <label class="muted">角度制<input id="deg" type="checkbox" checked></label>
        <label class="muted">反号(Yaw)<input id="invYaw" type="checkbox"></label>
        <label class="muted">反号(Pitch)<input id="invPitch" type="checkbox"></label>
        <label class="muted">反号(Roll)<input id="invRoll" type="checkbox"></label>
        <label class="muted">网格<input id="gridToggle" type="checkbox" checked></label>
        <label class="muted">坐标轴<input id="axesToggle" type="checkbox" checked></label>
      </div>

      <div class="row" style="margin-top:4px; gap:12px">
        <div class="muted">交互：<span class="kbd">中键</span>旋转 · <span class="kbd">Ctrl+中键</span>平移 · <span class="kbd">Shift+中键</span>变焦 · <span class="kbd">滚轮</span>缩放 · <span class="kbd">双击</span>复位</div>
        <div class="row">
          <button id="presetSW" class="btn" title="SolidWorks风格交互">SW 预设</button>
          <button id="presetDefault" class="btn" title="three.js 默认交互">默认预设</button>
        </div>
      </div>

      <div class="logbox" id="log"></div>
    </div>
  </div>

  <div class="legend" id="legend">状态：<span id="status">待机</span></div>
</div>

<!-- 本地脚本（r146 非模块 UMD） -->
<script src="./three.min.js"></script>
<script src="./OrbitControls.js"></script>
<script src="./STLLoader.js"></script>
<script>
(function(){
  // ====== 日志与状态（含限长） ======
  const LOG_MAX = 500; // ② 日志限长
  const logBox = document.getElementById('log');
  const log = (lvl, ...args)=>{
    const t=new Date().toLocaleTimeString();
    const d=document.createElement('div'); d.className='logline '+lvl; d.textContent=`[${t}] [${lvl}] `+args.join(' ');
    logBox.appendChild(d);
    // 超过上限则清理最早的 10%
    while(logBox.children.length>LOG_MAX){ for(let i=0;i<Math.ceil(LOG_MAX*0.1); i++){ logBox.removeChild(logBox.firstChild); } }
    logBox.scrollTop=logBox.scrollHeight;
  };
  const setStatus = s=> document.getElementById('status').textContent = s;

  if(!window.THREE){ alert('three.min.js 未加载'); return; }
  log('info', 'THREE r'+THREE.REVISION+' 已加载');

  // ====== 场景/渲染 ======
  const canvas = document.getElementById('viewer');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight, false);
  const scene = new THREE.Scene(); scene.background = new THREE.Color('#0b1221');
  const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.001, 1e7); camera.position.set(6,4,7);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping=true; controls.dampingFactor=0.08; // 更顺滑
  controls.screenSpacePanning=true; // 屏幕空间平移，CAD手感
  controls.zoomSpeed=1.0; controls.rotateSpeed=0.9; controls.panSpeed=0.8;
  controls.minDistance=0.001; controls.maxDistance=1e6;

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dir=new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(8,12,10); scene.add(dir);
  const grid=new THREE.GridHelper(10,20,0x335577,0x223344); grid.material.opacity=0.25; grid.material.transparent=true; scene.add(grid);
  const axes=new THREE.AxesHelper(1.5); scene.add(axes);

  // 渲染：仅在变化时绘制（降低主线程占用）
  let rafLock=false;
  function render(){ if(rafLock) return; rafLock=true; requestAnimationFrame(()=>{ rafLock=false; renderer.render(scene,camera); }); }
  controls.addEventListener('change', render);

  // ====== 视角复位 ======
  function fit(obj){
    if(!obj) return;
    const box=new THREE.Box3().setFromObject(obj);
    const size=box.getSize(new THREE.Vector3());
    const center=box.getCenter(new THREE.Vector3());
    const maxDim=Math.max(size.x,size.y,size.z)||1;
    const dist=maxDim/(2*Math.tan(Math.PI*camera.fov/360));
    const dirv=new THREE.Vector3(1,0.6,1).normalize();
    camera.position.copy(center.clone().add(dirv.multiplyScalar(dist*2)));
    camera.near=Math.max(0.001,maxDim/2000); camera.far=Math.max(1000,dist*60); camera.updateProjectionMatrix();
    controls.target.copy(center); controls.update(); render();
  }
  canvas.addEventListener('dblclick', ()=>{ if(model) fit(model); });

  // ====== SolidWorks风格交互映射 ======
  const DEFAULT_MAPPING = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
  const SW_MAPPING = { LEFT: THREE.MOUSE.NONE, MIDDLE: THREE.MOUSE.ROTATE, RIGHT: THREE.MOUSE.PAN };
  function applyMouseMapping(preset){
    const map = preset==='sw' ? SW_MAPPING : DEFAULT_MAPPING;
    controls.mouseButtons.LEFT = map.LEFT;
    controls.mouseButtons.MIDDLE = map.MIDDLE;
    controls.mouseButtons.RIGHT = map.RIGHT;
    log('info', '交互预设：', preset==='sw' ? 'SolidWorks' : 'three.js 默认');
  }
  applyMouseMapping('sw'); // 默认启用 SW 手感
  let modifierMode=null;
  addEventListener('keydown', (e)=>{
    if(e.repeat) return;
    if(e.key==='Control'){ modifierMode='PAN'; controls.mouseButtons.MIDDLE=THREE.MOUSE.PAN; }
    else if(e.key==='Shift'){ modifierMode='DOLLY'; controls.mouseButtons.MIDDLE=THREE.MOUSE.DOLLY; }
  });
  addEventListener('keyup', (e)=>{
    if((e.key==='Control' && modifierMode==='PAN') || (e.key==='Shift' && modifierMode==='DOLLY')){
      controls.mouseButtons.MIDDLE=THREE.MOUSE.ROTATE; modifierMode=null; render();
    }
  });

  // ====== 模型加载 ======
  const loader = new THREE.STLLoader();
  let model = null;
  function setModelGeometry(geo){
    try{ geo.computeBoundingBox(); const bb=geo.boundingBox; if(!bb) throw new Error('无包围盒');
      const size=new THREE.Vector3(); bb.getSize(size); const center=new THREE.Vector3(); bb.getCenter(center);
      const maxDim=Math.max(size.x,size.y,size.z)||1; geo.applyMatrix4(new THREE.Matrix4().makeTranslation(-center.x,-center.y,-center.z));
      if(maxDim>1e6 || maxDim<1e-6){ const s=1/maxDim; geo.applyMatrix4(new THREE.Matrix4().makeScale(s,s,s)); log('warn','归一化尺度 s=', s); }
      geo.computeVertexNormals();
    }catch(e){ log('warn','规范化失败', e.message); }
    const mesh=new THREE.Mesh(geo,new THREE.MeshNormalMaterial());
    if(model){ scene.remove(model); model.geometry.dispose(); model.material.dispose(); }
    model=mesh; model.position.set(0,0,0); scene.add(model); fit(model); log('info','模型就绪');
  }
  document.getElementById('stlFile').addEventListener('change', e=>{
    const f=e.target.files && e.target.files[0]; if(!f) return; const r=new FileReader();
    r.onload=()=>{ try{ setModelGeometry(loader.parse(r.result)); }catch(err){ alert('STL 解析失败: '+err); } };
    r.readAsArrayBuffer(f); e.target.value='';
  });
  document.getElementById('inlineSTL').addEventListener('click', ()=>{ const g=new THREE.BoxGeometry(1,0.3,0.6); setModelGeometry(g); });
  document.getElementById('fit').addEventListener('click', ()=>{ if(model) fit(model); });

  // ====== 姿态应用（仅旋转，不位移） ======
  const toRad = d=> d*Math.PI/180;
  function applyPose(pose){
    if(!model) return;
    if(pose.quat){ model.quaternion.set(pose.quat.x, pose.quat.y, pose.quat.z, pose.quat.w); }
    else if([pose.yaw,pose.pitch,pose.roll].every(v=> typeof v==='number')){
      const order=document.getElementById('eulerOrder').value;
      const invY=document.getElementById('invYaw').checked?-1:1;
      const invP=document.getElementById('invPitch').checked?-1:1;
      const invR=document.getElementById('invRoll').checked?-1:1;
      const isDeg=document.getElementById('deg').checked;
      const y=isDeg?toRad(pose.yaw):pose.yaw; const p=isDeg?toRad(pose.pitch):pose.pitch; const r=isDeg?toRad(pose.roll):pose.roll;
      const euler=new THREE.Euler(invP*p, invY*y, invR*r, order); // Y-up: yaw→Y, pitch→X, roll→Z
      model.setRotationFromEuler(euler);
    }
    render();
  }

  // ====== 解析器（$GPCHC/四元数/欧拉） ======
  function parseLine(line){
    const s=line? line.trim():''; if(!s) return {};
    const parts=s.split(',');
    function tryQuatAt(i){ const qx=+parts[i], qy=+parts[i+1], qz=+parts[i+2], qw=+parts[i+3]; if([qx,qy,qz,qw].every(Number.isFinite)){ const n=Math.hypot(qx,qy,qz,qw); if(n>0.5 && n<1.5) return {quat:{x:qx/n,y:qy/n,z:qz/n,w:qw/n}}; } return null; }
    for(let i=0;i<parts.length-3;i++){ const q=tryQuatAt(i); if(q) return q; }
    for(let i=0;i<Math.min(parts.length-2,16); i++){ const a=+parts[i], b=+parts[i+1], c=+parts[i+2]; if([a,b,c].every(v=> Number.isFinite(v) && Math.abs(v)<=360)) return { yaw:a, pitch:b, roll:c }; }
    return {};
  }

  // ====== 目录自动监测 + 播放（1~6点联合优化） ======
  let dirHandle=null, fileList=[], currentFile=null, timer=null, watcher=null, isPlaying=false, lastScanTs=0, currentMeta={mtime:0};
  let busy=false;          // ① 单次执行锁，防止重入
  let backoff=0;           // ⑤ 出错退避毫秒（指数退避上限 2000ms）

  async function pickDirectory(){
    try{ dirHandle=await window.showDirectoryPicker({ id:'test_data_dir' }); document.getElementById('dirStatus').textContent='已选择: '+dirHandle.name; log('info','目录授权成功:', dirHandle.name); if(document.getElementById('autoWatch').checked){ startAutoWatch(); } }
    catch(e){ log('error','目录授权失败', e.message); }
  }

  async function scanFiles(){
    if(!dirHandle) throw new Error('未选择目录');
    const list=[]; for await (const [name,handle] of dirHandle.entries()){ if(!name.toLowerCase().endsWith('.txt')) continue; try{ const f=await handle.getFile(); list.push({name,handle,mtime:f.lastModified, size:f.size}); }catch{ /* ignore */ } }
    function tsScore(n){ const m=n.match(/(\d{4})_(\d{2})_(\d{2})_(\d{2})_(\d{2})_(\d{2})/); if(!m) return 0; return Date.UTC(+m[1],+m[2]-1,+m[3],+m[4],+m[5],+m[6]); }
    list.sort((a,b)=> tsScore(a.name)-tsScore(b.name) || a.mtime-b.mtime);
    fileList=list; return fileList.length;
  }

  // ③ 仅读取文件尾部，默认最多 64KB；⑥ 保障末行完整
  async function readTailPose(fileHandle){
    const f=await fileHandle.getFile();
    const maxTail=64*1024; // 64KB 足够容纳数千行
    const start=Math.max(0, f.size - maxTail);
    const text=await f.slice(start, f.size).text();
    // 若切到了中间，第一行可能是残缺，丢弃之
    const seg = start>0 ? text.replace(/^[^\n]*\n/, '') : text;
    const lines=seg.split(/\r?\n/).filter(Boolean);
    // 优先找带 $GPCHC 的完整行；找不到就取最后一行
    let line='';
    for(let i=lines.length-1;i>=0;i--){ if(lines[i].includes('$GPCHC')){ line=lines[i]; break; } }
    if(!line) line = lines[lines.length-1] || '';
    return { pose: parseLine(line), name:f.name, mtime:f.lastModified };
  }

  async function startPlayback(){
    if(!dirHandle){ alert('请先选择 test_data 目录'); return; }
    if(!model){ alert('请先加载 STL 或使用内置立方体'); return; }

    const count=await scanFiles();
    if(count===0){ setStatus('等待数据...'); isPlaying=false; return; }

    // 选择最新文件作为“实时源”
    currentFile = fileList.length ? fileList[fileList.length-1] : null;
    currentMeta = { mtime: 0 };

    if(isPlaying) return;
    isPlaying=true; setStatus('播放中...');
    const baseInterval=Math.max(10, parseInt(document.getElementById('interval').value)||100);
    const rate=parseFloat(document.getElementById('rate').value||1);
    const rescanPeriod = Math.max(300, parseInt(document.getElementById('watchInterval').value)||1000); // ④ 目录重扫节流

    timer && clearInterval(timer);
    timer=setInterval(async ()=>{
      if(busy) return; busy=true;           // ① 单次执行锁
      try{
        // ④ 到期再重扫目录，避免每帧全扫
        const now = performance.now();
        if(now - lastScanTs > rescanPeriod){
          await scanFiles();
          if(fileList.length){ currentFile = fileList[fileList.length-1]; }
          lastScanTs = now;
        }
        if(!currentFile){ setStatus('等待数据...'); return; }

        // 仅当有新内容（mtime 变化）才读取尾部
        let f;
        try{ f = await currentFile.handle.getFile(); }
        catch(err){
          // ⑤ 可能写锁/权限临时失败：指数退避后再试
          backoff = Math.min(2000, Math.max(200, backoff*1.7|0));
          log('warn','文件读取失败，将退避', backoff,'ms：', err.message);
          await new Promise(r=> setTimeout(r, backoff));
          return;
        }
        if(f.lastModified === currentMeta.mtime){ backoff=0; return; }
        currentMeta.mtime = f.lastModified; backoff=0;

        const {pose,name}=await readTailPose(currentFile.handle);
        if(pose && (pose.quat || (typeof pose.yaw==='number'))){
          applyPose(pose); // 渲染在内部触发
        }else{
          log('warn','未解析到有效姿态（可能末行未完成）');
        }
        log('info','刷新:', name);
      }catch(e){
        log('error','解析失败', e.message);
      }finally{ busy=false; }
    }, baseInterval/Math.max(0.1, rate));
  }

  function stopPlayback(){ if(timer){ clearInterval(timer); timer=null; } isPlaying=false; setStatus('已停止'); }

  function startAutoWatch(){
    const enabled=document.getElementById('autoWatch').checked; const period=Math.max(300, parseInt(document.getElementById('watchInterval').value)||100);
    if(!enabled){ stopAutoWatch(); return; }
    if(!dirHandle){ setStatus('等待选择目录...'); return; }
    if(watcher) clearInterval(watcher);
    watcher=setInterval(async ()=>{
      try{ const n=await scanFiles(); if(n>0){ if(!isPlaying){ log('info','检测到数据，自动开始播放'); startPlayback(); } } else { if(!isPlaying) setStatus('等待数据...'); } }
      catch(e){ log('error','目录监测失败', e.message); }
    }, period);
    log('info','自动监测已开启，周期(ms)=', period);
  }
  function stopAutoWatch(){ if(watcher){ clearInterval(watcher); watcher=null; log('info','自动监测已停止'); } }

  // ====== 专注/全屏/可见性管理 ======
  const chrome = document.getElementById('chrome');
  const legend = document.getElementById('legend');
  document.getElementById('focusMode').addEventListener('click', ()=>{ const hide=!chrome.classList.contains('hidden'); chrome.classList.toggle('hidden', hide); legend.classList.toggle('hidden', hide); render(); });
  async function toggleFullscreen(){ try{ if(!document.fullscreenElement){ await document.documentElement.requestFullscreen(); } else { await document.exitFullscreen(); } } catch(err){ log('warn','全屏切换失败：', err.message); } }
  document.getElementById('fullscreen').addEventListener('click', toggleFullscreen);
  addEventListener('keydown', (e)=>{ if(e.key==='f' || e.key==='F') toggleFullscreen(); });

  // 标签页不可见时暂停刷新，回来再继续（避免堆积）
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ stopPlayback(); } else { if(!isPlaying && document.getElementById('autoWatch').checked){ startPlayback(); } }});

  // ====== 窗口尺寸节流 ======
  let resizeTid=null; addEventListener('resize', ()=>{ clearTimeout(resizeTid); resizeTid=setTimeout(()=>{ const w=innerWidth,h=innerHeight; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false); render(); },120); });

  // ====== 绑定 UI ======
  document.getElementById('pickDir').addEventListener('click', pickDirectory);
  document.getElementById('start').addEventListener('click', startPlayback);
  document.getElementById('stop').addEventListener('click', stopPlayback);
  document.getElementById('autoWatch').addEventListener('change', ()=>{ stopAutoWatch(); startAutoWatch(); });
  document.getElementById('watchInterval').addEventListener('change', ()=>{ stopAutoWatch(); startAutoWatch(); });
  document.getElementById('presetSW').addEventListener('click', ()=> applyMouseMapping('sw'));
  document.getElementById('presetDefault').addEventListener('click', ()=> applyMouseMapping('default'));
  document.getElementById('gridToggle').addEventListener('change', (e)=>{ grid.visible=e.target.checked; render(); });
  document.getElementById('axesToggle').addEventListener('change', (e)=>{ axes.visible=e.target.checked; render(); });

  // ====== 启动：内置立方体，便于无 STL 时先跑通渲染 ======
  (function(){ const g=new THREE.BoxGeometry(1,0.3,0.6); setModelGeometry(g); setStatus('待机'); render(); })();
})();
</script>
</body>
</html>